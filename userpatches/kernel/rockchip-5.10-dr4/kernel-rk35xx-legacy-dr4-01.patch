From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Wed, 7 Aug 2024 10:12:14 +0800
Subject: Patching kernel rk35xx files arch/arm64/boot/dts/rockchip/Makefile
 arch/arm64/boot/dts/rockchip/rk3566-dr4.dts
 arch/arm64/boot/dts/rockchip/rk3566-dr4.dtsi drivers/Makefile
 drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c drivers/rongpin/Kconfig
 drivers/rongpin/Makefile drivers/rongpin/rp_fan_power.c
 drivers/rongpin/rp_gpio.c drivers/rongpin/rp_keys.c
 drivers/rongpin/rp_power.c drivers/rongpin/stm706.c

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 arch/arm64/boot/dts/rockchip/Makefile          |    2 +-
 arch/arm64/boot/dts/rockchip/rk3566-dr4.dts    | 1358 ++++++++++
 arch/arm64/boot/dts/rockchip/rk3566-dr4.dtsi   |   69 +
 drivers/Makefile                               |    1 +
 drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c |   50 +-
 drivers/rongpin/Kconfig                        |   21 +
 drivers/rongpin/Makefile                       |    5 +
 drivers/rongpin/rp_fan_power.c                 |  294 ++
 drivers/rongpin/rp_gpio.c                      |  318 +++
 drivers/rongpin/rp_keys.c                      |  440 +++
 drivers/rongpin/rp_power.c                     |  349 +++
 drivers/rongpin/stm706.c                       |  171 ++
 12 files changed, 3065 insertions(+), 13 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
index aa008a5d35e7..2a600447a2a1 100644
--- a/arch/arm64/boot/dts/rockchip/Makefile
+++ b/arch/arm64/boot/dts/rockchip/Makefile
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
-dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-evb.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3566-dr4.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-evb-ddr3-v10.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-evb-ddr3-v10-avb.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-evb-ddr3-v10-linux.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-mini-evb-ddr3-v11.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-mini-evb-ddr3-v11-avb.dtb
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-dr4.dts b/arch/arm64/boot/dts/rockchip/rk3566-dr4.dts
new file mode 100644
index 000000000000..7ad485daf49b
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3566-dr4.dts
@@ -0,0 +1,1358 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ *
+ */
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/sensor-dev.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include "rk3566-dr4.dtsi"
+#include "rk3568-linux.dtsi"
+
+/ { 
+
+	model = "dr4-rk3566-rmt";
+	compatible = "rockchip,rk3566-dr4", "rockchip,rk3566";
+	
+
+	chosen: chosen {
+		bootargs = "earlycon=uart8250,mmio32,0xfe660000 console=ttyFIQ0";
+	};	
+ 
+    edp_panel:panel {
+        status = "disabled";
+    };
+
+    lvds_panel: panel@0 {
+        status = "disabled";
+    };
+
+    audiopwmout_diff: audiopwmout-diff {
+        status = "disabled";
+        compatible = "simple-audio-card";
+        simple-audio-card,format = "i2s";
+        simple-audio-card,name = "rockchip,audiopwmout-diff";
+        simple-audio-card,mclk-fs = <256>;
+        simple-audio-card,bitclock-master = <&master>;
+        simple-audio-card,frame-master = <&master>;
+        simple-audio-card,cpu {
+            sound-dai = <&i2s3_2ch>;
+        };
+        master: simple-audio-card,codec {
+            sound-dai = <&dig_acodec>;
+        };
+    };       
+        
+        
+    rk_headset: rk-headset {
+        compatible = "rockchip_headset";
+		status = "disabled";
+    };    
+
+    dc_12v: dc-12v {
+        compatible = "regulator-fixed";
+        regulator-name = "dc_12v";
+        regulator-always-on;
+        regulator-boot-on;
+        regulator-min-microvolt = <12000000>;
+        regulator-max-microvolt = <12000000>;
+    };
+
+    hdmi_sound: hdmi-sound {
+        status = "okay";	
+        compatible = "rockchip,hdmi";
+        rockchip,mclk-fs = <128>;
+        rockchip,name = "rockchip,hdmi";
+		rockchip,cpu = <&i2s0_8ch>;
+		rockchip,codec = <&hdmi>;
+		rockchip,jack-det;
+
+    };
+
+    pdmics: dummy-codec {
+        status = "disabled";
+        compatible = "rockchip,dummy-codec";
+        #sound-dai-cells = <0>;
+    };
+
+    pdm_mic_array: pdm-mic-array {
+        status = "disabled";
+        compatible = "simple-audio-card";
+        simple-audio-card,name = "rockchip,pdm-mic-array";
+        simple-audio-card,cpu {
+            sound-dai = <&pdm>;
+        };
+        simple-audio-card,codec {
+            sound-dai = <&pdmics>;
+        };
+    };
+
+    rk809_sound: rk809-sound {
+        status = "disabled";
+        compatible = "simple-audio-card";
+        simple-audio-card,format = "i2s";
+        simple-audio-card,name = "rockchip,rk809-codec";
+        simple-audio-card,mclk-fs = <256>;
+        simple-audio-card,cpu {
+            sound-dai = <&i2s1_8ch>;
+        };
+        simple-audio-card,codec {
+            sound-dai = <&rk809_codec>;
+        };		
+    };
+
+    spdif-sound {
+        status = "disabled";
+        compatible = "simple-audio-card";
+        simple-audio-card,name = "ROCKCHIP,SPDIF";
+        simple-audio-card,cpu {
+                sound-dai = <&spdif_8ch>;
+        };
+        simple-audio-card,codec {
+                sound-dai = <&spdif_out>;
+        };
+    };
+
+    spdif_out: spdif-out {
+            status = "disabled";
+            compatible = "linux,spdif-dit";
+            #sound-dai-cells = <0>;
+    };
+
+    vad_sound: vad-sound {
+        status = "disabled";
+        compatible = "rockchip,multicodecs-card";
+        rockchip,card-name = "rockchip,rk3568-vad";
+        rockchip,cpu = <&i2s1_8ch>;
+        rockchip,codec = <&rk809_codec>, <&vad>;
+    };
+
+    vcc3v3_sys: vcc3v3-sys {
+        compatible = "regulator-fixed";
+        regulator-name = "vcc3v3_sys";
+        regulator-always-on;
+        regulator-boot-on;
+        regulator-min-microvolt = <3300000>;
+        regulator-max-microvolt = <3300000>;
+        vin-supply = <&dc_12v>;
+    };
+
+    vcc5v0_sys: vcc5v0-sys {
+        compatible = "regulator-fixed";
+        regulator-name = "vcc5v0_sys";
+        regulator-always-on;
+        regulator-boot-on;
+        regulator-min-microvolt = <5000000>;
+        regulator-max-microvolt = <5000000>;
+        vin-supply = <&dc_12v>;
+    };
+
+
+    vcc3v3_lcd0_n: vcc3v3-lcd0-n {
+        compatible = "regulator-fixed";
+        regulator-name = "vcc3v3_lcd0_n";
+        regulator-boot-on;
+        regulator-min-microvolt = <3300000>;
+        regulator-max-microvolt = <3300000>;
+        enable-active-high;
+        //gpio = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
+        vin-supply = <&vcc3v3_sys>;
+
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+
+    vcc3v3_lcd1_n: vcc3v3-lcd1-n {
+        compatible = "regulator-fixed";
+        regulator-name = "vcc3v3_lcd1_n";
+        regulator-boot-on;
+        regulator-min-microvolt = <3300000>;
+        regulator-max-microvolt = <3300000>;
+        enable-active-high;
+        //gpio = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+        vin-supply = <&vcc3v3_sys>;
+
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+ 
+    sdio_pwrseq: sdio-pwrseq {
+        compatible = "mmc-pwrseq-simple";
+        clocks = <&rk809 1>;
+        clock-names = "ext_clock";
+        pinctrl-names = "default";
+        pinctrl-0 = <&wifi_enable_h>;
+
+        /*
+         * On the module itself this is one of these (depending
+         * on the actual card populated):
+         * - SDIO_RESET_L_WL_REG_ON
+         * - PDN (power down when low)
+         */
+        post-power-on-delay-ms = <200>;
+        reset-gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_LOW>;
+    };
+
+    wireless_wlan: wireless-wlan {
+        compatible = "wlan-platdata";
+        rockchip,grf = <&grf>;
+        wifi_chip_type = "ap6398s";
+        status = "disabled";
+    };
+
+    wireless_bluetooth: wireless-bluetooth {
+        compatible = "bluetooth-platdata";
+        clocks = <&rk809 1>;
+        clock-names = "ext_clock";
+        //wifi-bt-power-toggle;
+    uart_rts_gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_LOW>;
+    pinctrl-names = "default", "rts_gpio";
+    pinctrl-0 = <&uart1m1_rtsn>;
+    pinctrl-1 = <&uart1_gpios>;
+    BT,reset_gpio    = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
+    BT,wake_gpio     = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
+    BT,wake_host_irq = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+        status = "disabled";
+    };
+
+    test-power {
+        status = "okay";
+    };
+/*	
+	fan_gpio_control {
+		compatible = "fan_gpio_control";
+		gpio-pin = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+		temperature-device = "soc-thermal";
+		temp-on = <45000>;
+		time = <30000>;
+		status = "okay";
+    };
+*/        
+	rp_power{
+		status = "okay";
+		compatible = "rp_power";
+		rp_not_deep_sleep = <1>;
+		
+		//#define GPIO_FUNCTION_OUTPUT 0
+		//#define GPIO_FUNCTION_INPUT 1
+		//#define GPIO_FUNCTION_IRQ 2
+		//#define GPIO_FUNCTION_FLASH 3
+		//#define GPIO_FUNCTION_OUTPUT_CTRL 4
+		
+		/**
+		* gpioxxx {                    // the node name will display on /proc/rp_power, you can define any character string
+		*      gpio_num = <>;          // gpio you want ot control
+		*      gpio_function = <>;     // function of current gpio, refer to above define.
+		* };
+		*/
+		
+		
+		/******* sytem power en pin, donnot change it only if you know what you are doing */
+		pwr_en {        //vdd 12v/5v/3.3v enable
+			gpio_num = <&gpio2 RK_PB3 GPIO_ACTIVE_HIGH>;
+			gpio_function = <0>;
+		};
+		
+		vdd_3g {        //vdd_3G 3.3v enable
+			gpio_num = <&gpio1 RK_PC7 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+		
+		spk_en {        //SPK ENABLE
+			gpio_num = <&gpio4 RK_PC4 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+		
+		spk_mute {      //SPK MUTE, high active, nomal low
+			gpio_num = <&gpio0 RK_PA0 GPIO_ACTIVE_LOW>;
+			gpio_function = <4>;
+		};
+		
+		hub_rst {     //usb hub reset pin
+			gpio_num = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+		
+		host1_5v {     //host1 usb2.0 power en
+			gpio_num = <&gpio1 RK_PD1 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+		
+		host2_5v {     //host2 usb2.0 power en
+			gpio_num = <&gpio1 RK_PD2 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+		
+		host3_5v {     //host2 usb2.0 power en
+			gpio_num = <&gpio1 RK_PD4 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+		
+		usb20_5v {     //usb2.0 power en
+			gpio_num = <&gpio0 RK_PA5 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+		
+		usb30_5v {     //usb3.0 power en
+			gpio_num = <&gpio0 RK_PA6 GPIO_ACTIVE_HIGH>;
+			gpio_function = <4>;
+		};
+			
+		otg_idctl {
+			gpio_num = <&gpio0 RK_PC2 GPIO_ACTIVE_LOW>;
+			gpio_function = <0>;
+		};				
+			
+	};
+
+
+	rp_gpio{
+		status = "okay";
+		compatible = "rp_gpio";
+		
+		/***** gpio, add you want to control as blow */
+		
+		gpio0c5 {
+			gpio_num = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+			gpio_function = <0>;
+		};
+		gpio0c7 {
+			gpio_num = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
+			gpio_function = <0>;
+		};
+		gpio1a4 {
+			gpio_num = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+			gpio_function = <0>;
+		};             
+	};
+	
+    /** 24M osc clock to mcp2515 */
+    osc_24m: osc24m {
+        compatible = "fixed-clock";
+        #clock-cells = <0>;
+        clock-frequency = <24000000>;
+    };	
+	
+    backlight0: white {
+        compatible = "pwm-backlight";
+		power-supply = <&vcc3v3_sys>;
+        pwms = <&pwm4 0 25000 0>;
+        brightness-levels = <
+              0  20  20  21  21  22  22  23
+             23  24  24  25  25  26  26  27
+             27  28  28  29  29  30  30  31
+             31  32  32  33  33  34  34  35
+             35  36  36  37  37  38  38  39
+             40  41  42  43  44  45  46  47
+             48  49  50  51  52  53  54  55
+             56  57  58  59  60  61  62  63
+             64  65  66  67  68  69  70  71
+             72  73  74  75  76  77  78  79
+             80  81  82  83  84  85  86  87
+             88  89  90  91  92  93  94  95
+             96  97  98  99 100 101 102 103
+            104 105 106 107 108 109 110 111
+            112 113 114 115 116 117 118 119
+            120 121 122 123 124 125 126 127
+            128 129 130 131 132 133 134 135
+            136 137 138 139 140 141 142 143
+            144 145 146 147 148 149 150 151
+            152 153 154 155 156 157 158 159
+            160 161 162 163 164 165 166 167
+            168 169 170 171 172 173 174 175
+            176 177 178 179 180 181 182 183
+            184 185 186 187 188 189 190 191
+            192 193 194 195 196 197 198 199
+            200 201 202 203 204 205 206 207
+            208 209 210 211 212 213 214 215
+            216 217 218 219 220 221 222 223
+            224 225 226 227 228 229 230 231
+            232 233 234 235 236 237 238 239
+            240 241 242 243 244 245 246 247
+            248 249 250 251 252 253 254 255
+        >;
+        default-brightness-level = <255>;
+    };
+	
+    backlight2: red {
+        compatible = "pwm-backlight";
+		power-supply = <&vcc3v3_sys>;
+        pwms = <&pwm2 0 25000 0>;
+        brightness-levels = <
+              0  20  20  21  21  22  22  23
+             23  24  24  25  25  26  26  27
+             27  28  28  29  29  30  30  31
+             31  32  32  33  33  34  34  35
+             35  36  36  37  37  38  38  39
+             40  41  42  43  44  45  46  47
+             48  49  50  51  52  53  54  55
+             56  57  58  59  60  61  62  63
+             64  65  66  67  68  69  70  71
+             72  73  74  75  76  77  78  79
+             80  81  82  83  84  85  86  87
+             88  89  90  91  92  93  94  95
+             96  97  98  99 100 101 102 103
+            104 105 106 107 108 109 110 111
+            112 113 114 115 116 117 118 119
+            120 121 122 123 124 125 126 127
+            128 129 130 131 132 133 134 135
+            136 137 138 139 140 141 142 143
+            144 145 146 147 148 149 150 151
+            152 153 154 155 156 157 158 159
+            160 161 162 163 164 165 166 167
+            168 169 170 171 172 173 174 175
+            176 177 178 179 180 181 182 183
+            184 185 186 187 188 189 190 191
+            192 193 194 195 196 197 198 199
+            200 201 202 203 204 205 206 207
+            208 209 210 211 212 213 214 215
+            216 217 218 219 220 221 222 223
+            224 225 226 227 228 229 230 231
+            232 233 234 235 236 237 238 239
+            240 241 242 243 244 245 246 247
+            248 249 250 251 252 253 254 255
+        >;
+        default-brightness-level = <0>;
+    };	
+};
+
+&bus_npu {
+    bus-supply = <&vdd_logic>;
+    pvtm-supply = <&vdd_cpu>;
+    status = "okay";
+};
+
+&cpu0 {
+    cpu-supply = <&vdd_cpu>;
+};
+
+&rng {
+    status = "okay";
+};
+
+&dfi {
+    status = "okay";
+};
+
+&dmc {
+    center-supply = <&vdd_logic>;
+    status = "okay";
+};
+
+
+&gpu {
+    mali-supply = <&vdd_gpu>;
+    status = "okay";
+};
+
+/* old mali
+&gpu {
+	clock-names = "clk_mali", "clk_gpu";
+	interrupt-names = "GPU", "MMU", "JOB";
+    mali-supply = <&vdd_gpu>;
+    status = "okay";
+};
+
+&gpu_opp_table {
+		opp-200000000 {
+			opp-supported-hw = <0xfb 0xffff>;
+			opp-hz = /bits/ 64 <200000000>;
+			opp-microvolt = <850000 850000 1000000>;
+		};
+		opp-300000000 {
+			opp-supported-hw = <0xfb 0xffff>;
+			opp-hz = /bits/ 64 <300000000>;
+			opp-microvolt = <850000 850000 1000000>;
+		};
+		opp-400000000 {
+			opp-supported-hw = <0xfb 0xffff>;
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <850000 850000 1000000>;
+		};
+		opp-600000000 {
+			opp-supported-hw = <0xfb 0xffff>;
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <900000 900000 1000000>;
+			opp-microvolt-L0 = <900000 900000 1000000>;
+			opp-microvolt-L1 = <875000 875000 1000000>;
+			opp-microvolt-L2 = <850000 850000 1000000>;
+			opp-microvolt-L3 = <850000 850000 1000000>;
+		};
+		opp-700000000 {
+			opp-supported-hw = <0xfb 0xffff>;
+			opp-hz = /bits/ 64 <700000000>;
+			opp-microvolt = <950000 950000 1000000>;
+			opp-microvolt-L0 = <950000 950000 1000000>;
+			opp-microvolt-L1 = <925000 925000 1000000>;
+			opp-microvolt-L2 = <900000 900000 1000000>;
+			opp-microvolt-L3 = <875000 875000 1000000>;
+		};
+		opp-800000000 {
+			opp-supported-hw = <0xf9 0xffff>;
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1000000 1000000 1000000>;
+			opp-microvolt-L0 = <1000000 1000000 1000000>;
+			opp-microvolt-L1 = <975000 975000 1000000>;
+			opp-microvolt-L2 = <950000 950000 1000000>;
+			opp-microvolt-L3 = <925000 925000 1000000>;
+		};
+};
+*/
+
+&i2c0 {
+    status = "okay";
+
+    rk809: pmic@20 {
+        compatible = "rockchip,rk809";
+        reg = <0x20>;
+        interrupt-parent = <&gpio0>;
+        interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+        pinctrl-names = "default", "pmic-sleep",
+                "pmic-power-off", "pmic-reset";
+        pinctrl-0 = <&pmic_int>;
+        pinctrl-1 = <&soc_slppin_slp>, <&rk817_slppin_slp>;
+        pinctrl-2 = <&soc_slppin_gpio>, <&rk817_slppin_pwrdn>;
+        pinctrl-3 = <&soc_slppin_gpio>, <&rk817_slppin_rst>;
+
+        rockchip,system-power-controller;
+        wakeup-source;
+        #clock-cells = <1>;
+        clock-output-names = "rk808-clkout1", "rk808-clkout2";
+        //fb-inner-reg-idxs = <2>;
+        /* 1: rst regs (default in codes), 0: rst the pmic */
+        pmic-reset-func = <0>;
+        /* not save the PMIC_POWER_EN register in uboot */
+        not-save-power-en = <1>;
+
+        vcc1-supply = <&vcc3v3_sys>;
+        vcc2-supply = <&vcc3v3_sys>;
+        vcc3-supply = <&vcc3v3_sys>;
+        vcc4-supply = <&vcc3v3_sys>;
+        vcc5-supply = <&vcc3v3_sys>;
+        vcc6-supply = <&vcc3v3_sys>;
+        vcc7-supply = <&vcc3v3_sys>;
+        vcc8-supply = <&vcc3v3_sys>;
+        vcc9-supply = <&vcc3v3_sys>;
+
+        pwrkey {
+            status = "okay";
+        };
+
+        pinctrl_rk8xx: pinctrl_rk8xx {
+            gpio-controller;
+            #gpio-cells = <2>;
+
+            rk817_slppin_null: rk817_slppin_null {
+                pins = "gpio_slp";
+                function = "pin_fun0";
+            };
+
+            rk817_slppin_slp: rk817_slppin_slp {
+                pins = "gpio_slp";
+                function = "pin_fun1";
+            };
+
+            rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+                pins = "gpio_slp";
+                function = "pin_fun2";
+            };
+
+            rk817_slppin_rst: rk817_slppin_rst {
+                pins = "gpio_slp";
+                function = "pin_fun3";
+            };
+        };
+
+        regulators {
+            vdd_logic: DCDC_REG1 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <950000>;
+                regulator-max-microvolt = <1350000>;
+                regulator-init-microvolt = <950000>;
+                regulator-ramp-delay = <6001>;
+                regulator-initial-mode = <0x2>;
+                regulator-name = "vdd_logic";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vdd_gpu: DCDC_REG2 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <500000>;
+                regulator-max-microvolt = <1350000>;
+                regulator-init-microvolt = <900000>;
+                regulator-ramp-delay = <6001>;
+                regulator-initial-mode = <0x2>;
+                regulator-name = "vdd_gpu";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vcc_ddr: DCDC_REG3 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-initial-mode = <0x2>;
+                regulator-name = "vcc_ddr";
+                regulator-state-mem {
+                    regulator-on-in-suspend;
+                };
+            };
+
+            vdd_npu: DCDC_REG4 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <500000>;
+                regulator-max-microvolt = <1350000>;
+                regulator-init-microvolt = <900000>;
+                regulator-ramp-delay = <6001>;
+                regulator-initial-mode = <0x2>;
+                regulator-name = "vdd_npu";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vdda0v9_image: LDO_REG1 {
+                regulator-boot-on;
+                regulator-always-on;
+                regulator-min-microvolt = <900000>;
+                regulator-max-microvolt = <900000>;
+                regulator-name = "vdda0v9_image";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vdda_0v9: LDO_REG2 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <900000>;
+                regulator-max-microvolt = <900000>;
+                regulator-name = "vdda_0v9";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vdda0v9_pmu: LDO_REG3 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <900000>;
+                regulator-max-microvolt = <900000>;
+                regulator-name = "vdda0v9_pmu";
+                regulator-state-mem {
+                    regulator-on-in-suspend;
+                    regulator-suspend-microvolt = <900000>;
+                };
+            };
+
+            vccio_acodec: LDO_REG4 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <3000000>;
+                regulator-max-microvolt = <3000000>;
+                regulator-name = "vccio_acodec";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vccio_sd: LDO_REG5 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <3300000>;
+                regulator-name = "vccio_sd";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vcc3v3_pmu: LDO_REG6 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+                regulator-name = "vcc3v3_pmu";
+                regulator-state-mem {
+                    regulator-on-in-suspend;
+                    regulator-suspend-microvolt = <3300000>;
+                };
+            };
+
+            vcca_1v8: LDO_REG7 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <1800000>;
+                regulator-name = "vcca_1v8";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vcca1v8_pmu: LDO_REG8 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <1800000>;
+                regulator-name = "vcca1v8_pmu";
+                regulator-state-mem {
+                    regulator-on-in-suspend;
+                    regulator-suspend-microvolt = <1800000>;
+                };
+            };
+
+            vcca1v8_image: LDO_REG9 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <1800000>;
+                regulator-name = "vcca1v8_image";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vcc_1v8: DCDC_REG5 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <1800000>;
+                regulator-name = "vcc_1v8";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vcc_3v3: SWITCH_REG1 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-name = "vcc_3v3";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+
+            vcc3v3_sd: SWITCH_REG2 {
+                regulator-always-on;
+                regulator-boot-on;
+                regulator-name = "vcc3v3_sd";
+                regulator-state-mem {
+                    regulator-off-in-suspend;
+                };
+            };
+        };
+
+        rk809_codec: codec {
+            #sound-dai-cells = <0>;
+            compatible = "rockchip,rk809-codec", "rockchip,rk817-codec";
+            clocks = <&cru I2S1_MCLKOUT>;
+            clock-names = "mclk";
+            assigned-clocks = <&cru I2S1_MCLKOUT>, <&cru I2S1_MCLK_TX_IOE>;
+            assigned-clock-rates = <12288000>;
+            assigned-clock-parents = <&cru I2S1_MCLKOUT_TX>, <&cru I2S1_MCLKOUT_TX>;
+            pinctrl-names = "default";
+            pinctrl-0 = <&i2s1m0_mclk>;
+            hp-volume = <50>;    //3(max)-255(min)
+            spk-volume = <50>;    //3(max)-255(min)
+            capture_volume = <255>;
+            //mic-in-differential;
+            status = "okay";
+        };
+    };
+
+	vdd_cpu: tcs4525@1c {
+		compatible = "tcs,tcs452x";
+		reg = <0x1c>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		regulator-name = "vdd_cpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1390000>;
+		regulator-init-microvolt = <1000000>;
+		regulator-ramp-delay = <2300>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};	
+	
+};
+
+&i2c1 {
+    status = "okay";
+};
+
+&i2c4 {
+    status = "okay";
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c4m1_xfer>;
+
+        rtc@51 {
+                status = "okay";
+                compatible = "rtc,hym8563";
+                reg = <0x51>;
+                irq_gpio = <&gpio2 RK_PB4 GPIO_ACTIVE_LOW>;
+        };
+};
+
+&i2c5 {
+    status = "disabled";
+};
+
+&i2s0_8ch {
+    status = "disabled";
+};
+
+&i2s1_8ch {
+    status = "disabled";
+    rockchip,clk-trcm = <1>;
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2s1m0_sclktx
+             &i2s1m0_lrcktx
+             &i2s1m0_sdi0
+             &i2s1m0_sdo0>;
+};
+
+&iep {
+    status = "okay";
+};
+
+&iep_mmu {
+    status = "okay";
+};
+
+&jpegd {
+    status = "okay";
+};
+
+&jpegd_mmu {
+    status = "okay";
+};
+
+&mpp_srv {
+    status = "okay";
+};
+
+&nandc0 {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    status = "okay";
+
+    nand@0 {
+        reg = <0>;
+        nand-bus-width = <8>;
+        nand-ecc-mode = "hw";
+        nand-ecc-strength = <16>;
+        nand-ecc-step-size = <1024>;
+    };
+};
+
+&gmac1 {
+        phy-mode = "rgmii";
+        clock_in_out = "output";
+
+        snps,reset-gpio = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+        snps,reset-active-low;
+        /* Reset time is 20ms, 100ms for rtl8211f */
+        snps,reset-delays-us = <0 20000 100000>;
+
+        assigned-clocks = <&cru SCLK_GMAC1_RX_TX>, <&cru SCLK_GMAC1>, <&cru CLK_MAC1_OUT>;
+        assigned-clock-parents = <&cru SCLK_GMAC1_RGMII_SPEED>,<&gmac1_clkin>;
+        assigned-clock-rates = <0>, <125000000>, <25000000>;
+
+        pinctrl-names = "default";
+        pinctrl-0 = <&gmac1m0_miim
+                     &gmac1m0_tx_bus2
+                     &gmac1m0_rx_bus2
+                     &gmac1m0_rgmii_clk
+                     &gmac1m0_rgmii_bus
+                        &gmac1m0_clkinout
+            &eth1m0_pins>;
+
+		tx_delay = <0x4f>;
+		rx_delay = <0x34>;
+        phy-handle = <&rgmii_phy1>;
+        status = "okay";
+};
+
+&mdio1 {
+        rgmii_phy1: phy@0 {
+                compatible = "ethernet-phy-ieee802.3-c22";
+                reg = <0x0>;
+        clocks = <&cru CLK_MAC1_OUT>;
+        };
+};
+
+// jmb575 sata2 must open 
+&uart0 {
+	status = "okay";	
+};
+
+/*&uart3 { //AUDIOPWM
+    status = "okay";
+    pinctrl-names = "default";
+    pinctrl-0 = <&uart3m0_xfer>;
+};
+*/
+&uart5 { 
+    status = "okay";
+    pinctrl-names = "default";
+    pinctrl-0 = <&uart5m1_xfer>;
+};
+
+&uart6 { //okay
+        status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&uart6m0_xfer>;
+};
+
+&uart7 { 
+        status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&uart7m0_xfer>;
+};
+
+
+&uart9 { //okay
+        status = "disabled";
+        pinctrl-names = "default";
+        pinctrl-0 = <&uart9m0_xfer>;
+};
+
+
+&spi1 {
+        status = "disabled";
+        /* rewrite pinctrl, for cs1 used to be gpio */
+        pinctrl-0 = <&spi1m0_cs0 &spi1m0_pins>;
+        pinctrl-1 = <&spi1m0_cs0 &spi1m0_pins_hs>;
+        
+        spi2can: mcp2515@0 {
+            compatible = "microchip,mcp2515";
+            reg = <0>;
+            clocks = <&osc_24m>;
+            interrupt-parent = <&gpio2>;
+            interrupts = <RK_PC6 IRQ_TYPE_LEVEL_LOW>;
+            // vdd-supply = <&reg5v0>;
+            // xceiver-supply = <&reg5v0>;
+            spi-max-frequency = <10000000>;
+        };
+};
+
+&spi2 {
+        status = "okay";
+        /* rewrite pinctrl, for cs1 used to be gpio */
+        pinctrl-0 = <&spi2m0_cs0 &spi2m0_pins>;
+        pinctrl-1 = <&spi2m0_cs0 &spi2m0_pins_hs>;
+
+    spi2_dev@0 {
+        compatible = "rockchip,spidev";
+        reg = <0>;
+        spi-max-frequency = <12000000>;
+        spi-lsb-first;
+    };
+};
+
+&spi3 {
+    status = "okay";
+    
+    /* rewrite pinctrl for cs1 used to be camera clk */
+    pinctrl-0 = <&spi3m0_cs0 &spi3m0_pins>;
+    pinctrl-1 = <&spi3m0_cs0 &spi3m0_pins_hs>;
+
+    spi3_dev@0 {
+        compatible = "rockchip,spidev";
+        reg = <0>;
+        spi-max-frequency = <12000000>;
+        spi-lsb-first;
+    };
+};
+
+
+&pinctrl {
+
+    pmic {
+        pmic_int: pmic_int {
+            rockchip,pins =
+                <0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+        };
+
+        soc_slppin_gpio: soc_slppin_gpio {
+            rockchip,pins =
+                <0 RK_PA2 RK_FUNC_GPIO &pcfg_output_low_pull_down>;
+        };
+
+        soc_slppin_slp: soc_slppin_slp {
+            rockchip,pins =
+                <0 RK_PA2 1 &pcfg_pull_up>;
+        };
+
+        soc_slppin_rst: soc_slppin_rst {
+            rockchip,pins =
+                <0 RK_PA2 2 &pcfg_pull_none>;
+        };
+    };
+
+    sdio-pwrseq {
+        wifi_enable_h: wifi-enable-h {
+            rockchip,pins = <3 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+        };
+    };
+
+    wireless-bluetooth {
+        uart1_gpios: uart1-gpios {
+            rockchip,pins = <4 RK_PB6 RK_FUNC_GPIO &pcfg_pull_none>;
+        };
+    };
+};
+
+ /*
+  * There are 10 independent IO domains in RK3566/RK3568, including PMUIO[0:2] and VCCIO[1:7].
+  * 1/ PMUIO0 and PMUIO1 are fixed-level power domains which cannot be configured;
+  * 2/ PMUIO2 and VCCIO1,VCCIO[3:7] domains require that their hardware power supply voltages
+  *    must be consistent with the software configuration correspondingly
+  *    a/ When the hardware IO level is connected to 1.8V, the software voltage configuration
+  *       should also be configured to 1.8V accordingly;
+  *    b/ When the hardware IO level is connected to 3.3V, the software voltage configuration
+  *       should also be configured to 3.3V accordingly;
+  * 3/ VCCIO2 voltage control selection (0xFDC20140)
+  *    BIT[0]: 0x0: from GPIO_0A7 (default)
+  *    BIT[0]: 0x1: from GRF
+  *    Default is determined by Pin FLASH_VOL_SEL/GPIO0_A7:
+  *    L:VCCIO2 must supply 3.3V
+  *    H:VCCIO2 must supply 1.8V
+  */
+&pmu_io_domains {
+	status = "okay";
+	pmuio2-supply = <&vcc3v3_pmu>;
+	vccio1-supply = <&vccio_acodec>;
+	vccio3-supply = <&vccio_sd>;
+	vccio4-supply = <&vcc_3v3>;
+	vccio5-supply = <&vcc_3v3>;
+	vccio6-supply = <&vcc_1v8>;
+	vccio7-supply = <&vcc_3v3>;
+};
+
+
+&rk_rga {
+    status = "okay";
+};
+
+&rkvdec {
+    status = "okay";
+};
+
+&rkvdec_mmu {
+    status = "okay";
+};
+
+&rkvenc {
+    venc-supply = <&vdd_logic>;
+    status = "okay";
+};
+
+&rkvenc_mmu {
+    status = "okay";
+};
+
+&rknpu {
+    rknpu-supply = <&vdd_npu>;
+    status = "okay";
+};
+
+&rknpu_mmu {
+    status = "okay";
+};
+
+&hdmi {
+    status = "okay";
+    rockchip,phy-table =
+        <92812500  0x8009 0x0000 0x0270>,
+        <165000000 0x800b 0x0000 0x026d>,
+        <185625000 0x800b 0x0000 0x01ed>,
+        <297000000 0x800b 0x0000 0x01ad>,
+        <594000000 0x8029 0x0000 0x0088>,
+        <000000000 0x0000 0x0000 0x0000>;	
+};
+
+&hdmi_in_vp0 {
+    status = "okay";
+};
+
+&hdmi_in_vp1 {
+    status = "disabled";
+};
+
+&route_hdmi {
+    status = "okay";
+    connect = <&vp0_out_hdmi>;
+};
+
+&saradc {
+    status = "okay";
+    vref-supply = <&vcca_1v8>;
+};
+
+&sdhci {
+    bus-width = <8>;
+    supports-emmc;
+    non-removable;
+    max-frequency = <200000000>;
+    status = "okay";
+};
+
+&sdmmc0 {
+    max-frequency = <150000000>;
+    supports-sd;
+    bus-width = <4>;
+    cap-mmc-highspeed;
+    cap-sd-highspeed;
+    disable-wp;
+    sd-uhs-sdr104;
+    vmmc-supply = <&vcc3v3_sd>;
+    vqmmc-supply = <&vccio_sd>;
+    pinctrl-names = "default";
+    pinctrl-0 = <&sdmmc0_bus4 &sdmmc0_clk &sdmmc0_cmd &sdmmc0_det>;
+    status = "okay";
+};
+
+&sdmmc2 {
+    max-frequency = <150000000>;
+    supports-sdio;
+    bus-width = <4>;
+    disable-wp;
+    cap-sd-highspeed;
+    cap-sdio-irq;
+    keep-power-in-suspend;
+    mmc-pwrseq = <&sdio_pwrseq>;
+    non-removable;
+    pinctrl-names = "default";
+    pinctrl-0 = <&sdmmc2m0_bus4 &sdmmc2m0_cmd &sdmmc2m0_clk>;
+    sd-uhs-sdr104;
+    status = "disabled";
+};
+
+&sfc {
+    status = "okay";
+};
+
+&spdif_8ch {
+    status = "disabled";
+};
+
+&tsadc {
+    status = "okay";
+};
+
+&combphy0_us {
+    status = "okay";
+};
+
+&usb2phy1 {
+    status = "okay";
+};
+
+&u2phy1_host {
+    status = "okay";
+};
+
+&u2phy1_otg {
+    status = "okay";
+};
+
+&u2phy0_host {
+//    phy-supply = <&vcc5v0_host>;
+    status = "okay";
+};
+
+&u2phy0_otg {
+//    vbus-supply = <&vcc5v0_otg>;
+    status = "okay";
+};
+
+&usb2phy0 {
+    status = "okay";
+};
+
+&usbdrd_dwc3 {
+    dr_mode = "host";
+    extcon = <&usb2phy0>;
+    status = "okay";
+	
+//add
+	quirk-skip-phy-init;
+	snps,usb2-lpm-disable;
+	
+};
+
+&usb_host0_ehci {
+    status = "okay";
+};
+
+&usb_host0_ohci {
+    status = "okay";
+};
+
+&usb_host1_ehci {
+    status = "okay";
+};
+
+&usb_host1_ohci {
+    status = "okay";
+};
+
+&usbdrd30 {
+    status = "okay";
+};
+
+&usbhost_dwc3 {
+    status = "okay";
+};
+
+&usbhost30 {
+    status = "okay";
+};
+
+&vad {
+    rockchip,audio-src = <&i2s1_8ch>;
+    rockchip,buffer-time-ms = <128>;
+    rockchip,det-channel = <0>;
+    rockchip,mode = <0>;
+};
+
+&vdpu {
+    status = "okay";
+};
+
+&vdpu_mmu {
+    status = "okay";
+};
+
+&vepu {
+    status = "okay";
+};
+
+&vepu_mmu {
+    status = "okay";
+};
+
+&vop {
+    status = "okay";
+    assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>;
+    assigned-clock-parents = <&pmucru PLL_HPLL>, <&cru PLL_VPLL>;
+};
+
+&vop_mmu {
+    status = "okay";
+};
+
+&dsi0 {
+dsi0_panel: panel@0 {
+            status = "disabled";
+        };
+};
+
+&dsi1 {
+dsi1_panel: panel@0 {
+            status = "disabled";
+        };
+};
+
+
+&audiopwmout_diff {
+    status = "disabled";
+};
+
+&dig_acodec {
+    status = "disabled";
+    rockchip,pwm-output-mode;
+    pinctrl-names = "default";
+    pinctrl-0 = <&audiopwm_loutp
+        &audiopwm_loutn
+        &audiopwm_routp
+        &audiopwm_routn
+    >;
+};
+&pdm {
+    status = "disabled";
+    pinctrl-names = "default";
+    pinctrl-0 = <&pdmm1_clk1
+             &pdmm1_sdi1
+             &pdmm1_sdi2
+             &pdmm1_sdi3>;
+};
+
+&pdmics {
+    status = "disabled";
+};
+
+&pdm_mic_array {
+    status = "disabled";
+};
+
+// sata usb30 pcie phys
+
+&combphy1_usq {
+    status = "okay";
+};
+
+&combphy2_psq {
+    status = "okay";
+};
+
+&sata0 {
+    status = "disabled";
+};
+
+&sata1 {
+    status = "disabled";
+};
+
+&sata2 {
+    status = "okay";
+};
+
+&pwm0 {
+    status = "okay";
+};
+
+&pwm2 {
+    status = "okay";
+};
+
+/* about beep*/
+&pwm4 {
+    status = "okay";
+};
+
+&pwm6 {
+    status = "okay";
+};
+    
+&pwm7 {
+    /** disable for used to be led control */
+    status = "disabled";
+};
+	
+//gpio0_b0 for hub reset pin
+/delete-node/ &xin32k;
+
+&rockchip_suspend {
+	status = "disabled";
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-dr4.dtsi b/arch/arm64/boot/dts/rockchip/rk3566-dr4.dtsi
new file mode 100644
index 000000000000..7c7561787a6c
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3566-dr4.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ */
+
+#include "rk3568.dtsi"
+
+/ {
+	aliases {
+		/delete-property/ ethernet0;
+		/delete-property/ lvds1;
+	};
+};
+
+&cpu0_opp_table {
+	/delete-node/ opp-1992000000;
+};
+
+&lpddr4_params {
+	/* freq info, freq_0 is final frequency, unit: MHz */
+	freq_0 = <1056>;
+};
+
+&lpddr4x_params {
+	/* freq info, freq_0 is final frequency, unit: MHz */
+	freq_0 = <1056>;
+};
+
+&power {
+	pd_pipe@RK3568_PD_PIPE {
+		reg = <RK3568_PD_PIPE>;
+		clocks = <&cru PCLK_PIPE>;
+		pm_qos = <&qos_pcie2x1>,
+			 <&qos_sata1>,
+			 <&qos_sata2>,
+			 <&qos_usb3_0>,
+			 <&qos_usb3_1>;
+	};
+};
+
+&rkisp {
+	rockchip,iq-feature = /bits/ 64 <0x1BFBF7FE67FF>;
+};
+
+&usbdrd_dwc3 {
+	phys = <&u2phy0_otg>;
+	phy-names = "usb2-phy";
+	extcon = <&usb2phy0>;
+	maximum-speed = "high-speed";
+	snps,dis_u2_susphy_quirk;
+	snps,usb2-lpm-disable;
+};
+
+///delete-node/ &combphy0_us;
+/delete-node/ &gmac0_clkin;
+/delete-node/ &gmac0_xpcsclk;
+/delete-node/ &gmac0;
+/delete-node/ &gmac_uio0;
+/delete-node/ &lvds1;
+/delete-node/ &pcie30_phy_grf;
+/delete-node/ &pcie30phy;
+/delete-node/ &pcie3x1;
+/delete-node/ &pcie3x2;
+/delete-node/ &qos_pcie3x1;
+/delete-node/ &qos_pcie3x2;
+/delete-node/ &qos_sata0;
+///delete-node/ &sata0;
+/delete-node/ &vp1_out_lvds1;
+/delete-node/ &vp2_out_lvds1;
diff --git a/drivers/Makefile b/drivers/Makefile
index 21cb5565c1d5..9695850dd200 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -191,5 +191,6 @@ obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
 obj-$(CONFIG_RK_FLASH)		+= rkflash/
 obj-$(CONFIG_RK_HEADSET)	+= headset_observe/
 obj-$(CONFIG_RK_NAND)		+= rk_nand/
 obj-$(CONFIG_ROCKCHIP_RKNPU)	+= rknpu/
+obj-y				+= rongpin/
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
index cf9c46ea426e..8892191ac40b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
@@ -25,13 +25,16 @@
 #include <linux/regmap.h>
 #include <linux/pm_runtime.h>
 #include <linux/soc/rockchip/rk_vendor_storage.h>
 #include "stmmac_platform.h"
 #include "dwmac-rk-tool.h"
+#include <asm/system_info.h>
 
 #define MAX_ETH		2
 
+static int dev_num = 0;
+
 struct rk_priv_data;
 struct rk_gmac_ops {
 	void (*set_to_rgmii)(struct rk_priv_data *bsp_priv,
 			     int tx_delay, int rx_delay);
 	void (*set_to_rmii)(struct rk_priv_data *bsp_priv);
@@ -2709,10 +2712,34 @@ int dwmac_rk_get_phy_interface(struct stmmac_priv *priv)
 
 	return bsp_priv->phy_iface;
 }
 EXPORT_SYMBOL(dwmac_rk_get_phy_interface);
 
+/*
+ * Create an ethernet address from the system serial number.
+ */
+static int __init etherm_addr(char *addr)
+{
+	unsigned int serial;
+
+	if (system_serial_low == 0 && system_serial_high == 0)
+		return -ENODEV;
+
+	serial = system_serial_low | system_serial_high;
+
+	addr[0] = 0;
+	addr[1] = 0;
+	addr[2] = 0xa4;
+	addr[3] = 0x10 + (serial >> 24);
+	addr[4] = serial >> 16;
+	addr[5] = (serial >> 8) + dev_num;
+
+	dev_num++;
+
+	return 0;
+}
+
 static void rk_get_eth_addr(void *priv, unsigned char *addr)
 {
 	struct rk_priv_data *bsp_priv = priv;
 	struct device *dev = &bsp_priv->pdev->dev;
 	unsigned char ethaddr[ETH_ALEN * MAX_ETH] = {0};
@@ -2727,25 +2754,24 @@ static void rk_get_eth_addr(void *priv, unsigned char *addr)
 	}
 
 	ret = rk_vendor_read(LAN_MAC_ID, ethaddr, ETH_ALEN * MAX_ETH);
 	if (ret <= 0 ||
 	    !is_valid_ether_addr(&ethaddr[id * ETH_ALEN])) {
-		dev_err(dev, "%s: rk_vendor_read eth mac address failed (%d)\n",
-			__func__, ret);
-		random_ether_addr(&ethaddr[id * ETH_ALEN]);
+		//random_ether_addr(&ethaddr[id * ETH_ALEN]);
+		etherm_addr(&ethaddr[id * ETH_ALEN]);
 		memcpy(addr, &ethaddr[id * ETH_ALEN], ETH_ALEN);
-		dev_err(dev, "%s: generate random eth mac address: %pM\n", __func__, addr);
+		dev_err(dev, "%s: use serial to generate eth mac address: %pM\n", __func__, addr);
 
-		ret = rk_vendor_write(LAN_MAC_ID, ethaddr, ETH_ALEN * MAX_ETH);
-		if (ret != 0)
-			dev_err(dev, "%s: rk_vendor_write eth mac address failed (%d)\n",
-				__func__, ret);
+		//ret = rk_vendor_write(LAN_MAC_ID, ethaddr, ETH_ALEN * MAX_ETH);
+		//if (ret != 0)
+		//	dev_err(dev, "%s: rk_vendor_write eth mac address failed (%d)\n",
+		//		__func__, ret);
 
-		ret = rk_vendor_read(LAN_MAC_ID, ethaddr, ETH_ALEN * MAX_ETH);
-		if (ret != ETH_ALEN * MAX_ETH)
-			dev_err(dev, "%s: id: %d rk_vendor_read eth mac address failed (%d)\n",
-				__func__, id, ret);
+		//ret = rk_vendor_read(LAN_MAC_ID, ethaddr, ETH_ALEN * MAX_ETH);
+		//if (ret != ETH_ALEN * MAX_ETH)
+		//	dev_err(dev, "%s: id: %d rk_vendor_read eth mac address failed (%d)\n",
+		//		__func__, id, ret);
 	} else {
 		memcpy(addr, &ethaddr[id * ETH_ALEN], ETH_ALEN);
 	}
 
 out:
diff --git a/drivers/rongpin/Kconfig b/drivers/rongpin/Kconfig
new file mode 100644
index 000000000000..031091b1e9b1
--- /dev/null
+++ b/drivers/rongpin/Kconfig
@@ -0,0 +1,21 @@
+
+menu "rongpin support"
+
+config RP_POWER
+	tristate "rongpin power_ctrl support"
+	default y
+	help 
+		rp_power_ctrl
+
+config RP_GPIO
+	default y
+	tristate "rongpin rp gpio_ctl support"
+
+config RP_STM706
+        tristate "rongpin rp stm706 support"
+        default y
+
+config RP_FAN
+        default y
+        tristate "rongpin rp fan_ctl support"
+endmenu
diff --git a/drivers/rongpin/Makefile b/drivers/rongpin/Makefile
new file mode 100644
index 000000000000..1df9af9f2fc8
--- /dev/null
+++ b/drivers/rongpin/Makefile
@@ -0,0 +1,5 @@
+obj-y				+= rp_power.o
+obj-y				+= rp_gpio.o
+obj-$(CONFIG_RP_STM706)      	+= stm706.o
+obj-y           += rp_fan_power.o
+obj-y += rp_keys.o
diff --git a/drivers/rongpin/rp_fan_power.c b/drivers/rongpin/rp_fan_power.c
new file mode 100644
index 000000000000..784c356dcb66
--- /dev/null
+++ b/drivers/rongpin/rp_fan_power.c
@@ -0,0 +1,294 @@
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/irq.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+// #include <linux/wakelock.h>
+#include <linux/version.h>
+#include <linux/workqueue.h>
+#include <linux/thermal.h>
+#include <linux/timer.h>
+#define GPIO_PIN 50
+#define GPIO_NUM_MAX 40
+//static dev_t dev;
+//static struct cdev cdev;
+static struct workqueue_struct *fan_gpio_workqueue;
+//static struct work_struct fan_gpio_work;
+//static struct timer_list fan_gpio_timer;
+
+struct fan_gpio{
+	int gpio_num;
+	int action;
+	int temp_on;
+	int time;
+};
+
+struct fan_gpio_control_data {
+    struct fan_gpio fan_gpio_num;
+    char thermal_zone_device;   
+};
+
+static char* file_name = NULL;
+static struct fan_gpio_control_data *fan_gpio_data = NULL;
+//static int open_now = 1;
+static int fan_temp;
+static int fan_time;
+static const char *thermal_device;
+
+static int fan_gpio_open(struct inode *inode, struct file *file)
+{
+        struct dentry* dent = file->f_path.dentry;
+        //int i = 0;
+
+        file_name = (char*)(dent->d_name.name);
+
+        /*for (i = 0; i < fan_gpio_data->gpio_dts_num; i++){
+                if(!strcmp(file_name,fan_gpio_data->fan_gpio_num[i].gpio_name)){
+                        open_now = i;
+                }
+        }*/
+        return 0;
+}
+
+
+static ssize_t fan_gpio_write(struct file *file, const char *buffer,size_t count, loff_t *data)
+{
+    char temp_str[20];  
+    int ret;
+
+    ret = copy_from_user(temp_str, buffer, min(count, sizeof(temp_str) - 1));
+    if (ret < 0) {
+        return ret;
+    }
+
+    temp_str[count] = '\0';
+
+    ret = kstrtoint(temp_str, 10, &fan_temp);
+    if (ret < 0) {
+        pr_err("Failed to convert input to integer\n");
+        return ret;
+    }
+
+	return count;
+}
+
+static ssize_t fan_gpio_read(struct file *file, char __user * buffer, size_t count, loff_t *data)
+{	
+    int *new_temp_on = &fan_temp;
+    char temp_str[10];  
+    int len;
+    
+    len = snprintf(temp_str, sizeof(temp_str), "%d\n", *new_temp_on);
+
+    temp_str[len] = '\0';
+
+    return simple_read_from_buffer(buffer, count, data, temp_str, len);
+}	
+
+static int fan_time_open(struct inode *inode, struct file *file)
+{
+        struct dentry* dent = file->f_path.dentry;
+        //int i = 0;
+
+        file_name = (char*)(dent->d_name.name);
+
+        /*for (i = 0; i < fan_gpio_data->gpio_dts_num; i++){
+                if(!strcmp(file_name,fan_gpio_data->fan_gpio_num[i].gpio_name)){
+                        open_now = i;
+                }
+        }*/
+        return 0;
+}
+
+
+static ssize_t fan_time_write(struct file *file, const char *buffer,size_t count, loff_t *data)
+{
+    char time_str[20];
+    int ret;
+
+    ret = copy_from_user(time_str, buffer, min(count, sizeof(time_str) - 1));
+    if (ret < 0) {
+        return ret;
+    }
+
+    time_str[count] = '\0';
+
+    ret = kstrtoint(time_str, 10, &fan_time);
+    if (ret < 0) {
+        pr_err("Failed to convert input to integer\n");
+        return ret;
+    }
+
+        return count;
+}
+
+static ssize_t fan_time_read(struct file *file, char __user * buffer, size_t count, loff_t *data)
+{
+    int *new_time = &fan_time;
+    char time_str[10];
+    int len;
+
+    len = snprintf(time_str, sizeof(time_str), "%d\n", *new_time);
+
+    time_str[len] = '\0';
+
+    return simple_read_from_buffer(buffer, count, data, time_str, len);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+static const struct proc_ops fan_gpio_ops = {
+    .proc_open           = fan_gpio_open,
+    .proc_write          = fan_gpio_write,
+    .proc_read		 = fan_gpio_read,
+};
+static const struct proc_ops fan_time_ops = {
+    .proc_open           = fan_time_open,
+    .proc_write          = fan_time_write,
+    .proc_read           = fan_time_read,
+};
+#else
+static struct file_operations fan_gpio_fops = {
+    .owner = THIS_MODULE,
+    .open = fan_gpio_open,
+    .write = fan_gpio_write,
+    .read  = fan_gpio_read,
+};
+static struct file_operations fan_time_fops = {
+    .owner = THIS_MODULE,
+    .open = fan_time_open,
+    .write = fan_time_write,
+    .read  = fan_time_read,
+};
+#endif
+
+static struct delayed_work fan_gpio_delayed_work;
+
+static void fan_gpio_delayed_work_callback(struct work_struct *work){
+	int temperature;
+	struct thermal_zone_device *thermal_dev;
+	int temp;
+	
+	thermal_dev = thermal_zone_get_zone_by_name(thermal_device);
+
+	temp = thermal_zone_get_temp(thermal_dev, &temperature);
+
+	if(temperature < fan_temp) {
+
+         gpio_set_value(fan_gpio_data->fan_gpio_num.gpio_num, 0);
+         queue_delayed_work(fan_gpio_workqueue, &fan_gpio_delayed_work, msecs_to_jiffies(1000));
+	}
+	else if(temperature >= fan_temp) {
+
+	 gpio_set_value(fan_gpio_data->fan_gpio_num.gpio_num, 1);
+	 queue_delayed_work(fan_gpio_workqueue, &fan_gpio_delayed_work, msecs_to_jiffies(fan_time));
+	}
+	else{
+	printk("error:work_handler failed");
+	queue_delayed_work(fan_gpio_workqueue, &fan_gpio_delayed_work, msecs_to_jiffies(1000));
+	}
+
+};
+
+//static void fan_gpio_timer_callback(struct timer_list *t){
+//	queue_work(fan_gpio_workqueue, &fan_gpio_work);
+//}
+
+static int fan_gpio_probe(struct platform_device *pdev){
+    
+    int ret;
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *tmp = pdev->dev.of_node;
+    enum of_gpio_flags  gpio_flags;
+    static struct proc_dir_entry *root_entry_fan;
+    //struct device_node *child_np;
+
+   printk("init fan_gpio probe");
+
+   fan_gpio_data = devm_kzalloc(&pdev->dev, sizeof(struct fan_gpio_control_data), GFP_KERNEL);
+   
+   if (!fan_gpio_data) {
+        
+	   return -ENOMEM;
+    }
+
+   //Get Data from DTS
+   fan_gpio_data->fan_gpio_num.gpio_num = of_get_named_gpio_flags(np, "gpio-pin", 0, &gpio_flags);
+   fan_gpio_data->thermal_zone_device = of_property_read_string(tmp, "temperature-device", &thermal_device);
+   of_property_read_u32(np, "temp-on",&fan_temp);
+   of_property_read_u32(np, "time",&fan_time);
+   
+
+   ret = gpio_request(fan_gpio_data->fan_gpio_num.gpio_num, "fan_gpio_control");
+   if(ret < 0){
+        
+	   pr_err("Failed to request GPIO %d\n", GPIO_PIN);
+        
+	   return -EINVAL;
+    }
+
+    gpio_direction_output(fan_gpio_data->fan_gpio_num.gpio_num, gpio_flags);
+
+    //Create proc/rp_fan
+    root_entry_fan = proc_mkdir("rp_fan", NULL);
+    proc_create("temp", 0666 , root_entry_fan , &fan_gpio_ops);
+    proc_create("time", 0666 , root_entry_fan , &fan_time_ops);
+
+    //Work team
+    fan_gpio_workqueue = create_workqueue("fan_gpio_workqueue");
+    if(!fan_gpio_workqueue) {
+	    
+	    pr_err("Failed to get work handler");
+	    return -EINVAL;
+    }
+    
+    INIT_DELAYED_WORK(&fan_gpio_delayed_work, fan_gpio_delayed_work_callback);
+    queue_delayed_work(fan_gpio_workqueue, &fan_gpio_delayed_work, msecs_to_jiffies(1000));   
+
+
+    //timer
+    //timer_setup(&fan_gpio_timer,fan_gpio_timer_callback,0);
+    //mod_timer(&fan_gpio_timer, jiffies + msecs_to_jiffies(1000));
+
+    platform_set_drvdata(pdev, fan_gpio_data);
+    pr_info("GPIO Control Driver Loaded\n");
+    return 0;
+}
+
+static int fan_gpio_remove(struct platform_device *pdev) {
+
+    pr_info("GPIO Control Driver Unloaded\n");
+    return 0;
+}
+
+static const struct of_device_id gpio_of_match[] = {
+    { .compatible = "fan_gpio_control" },
+    { }
+};
+
+static struct platform_driver fan_gpio_driver = {
+    .probe = fan_gpio_probe,
+    .remove = fan_gpio_remove,
+    .driver = {
+                .name           = "fan_gpio_control",
+                .of_match_table = of_match_ptr(gpio_of_match),
+        },
+};
+
+
+MODULE_LICENSE("GPL");
+module_platform_driver(fan_gpio_driver);
diff --git a/drivers/rongpin/rp_gpio.c b/drivers/rongpin/rp_gpio.c
new file mode 100644
index 000000000000..b8fa06b8c3ee
--- /dev/null
+++ b/drivers/rongpin/rp_gpio.c
@@ -0,0 +1,318 @@
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include <linux/workqueue.h>
+
+
+#define GPIO_NUM_MAX 40
+
+#define GPIO_FUNCTION_OUTPUT 0
+#define GPIO_FUNCTION_INPUT 1
+#define GPIO_FUNCTION_IRQ 2
+#define GPIO_FUNCTION_FLASH 3
+
+static int flash_flag = 0;
+
+struct rp_gpio {
+	int gpio_num;		//gpui num
+	int gpio_irq;
+	int action;			//gpio flag
+	int gpio_event;		//input only
+	int send_mode;		//input only
+	int gpio_function;	//gpio function,i/o
+	int gpio_ctrl;
+	char *gpio_name;
+};
+
+struct rp_gpio_data {
+	struct rp_gpio rp_gpio_num[GPIO_NUM_MAX];
+	struct input_dev *input;
+	struct timer_list mytimer;
+	int gpio_dts_num;
+};
+
+static struct rp_gpio_data *gpio_data = NULL;
+static int event_flag = 0;
+static int open_now = 0;
+static char* file_name = NULL;
+
+
+static int gpio_open(struct inode *inode, struct file *file)
+{
+	struct dentry* dent = file->f_path.dentry;
+	int i = 0;
+
+	file_name = (char*)(dent->d_name.name);
+
+	for (i = 0; i < gpio_data->gpio_dts_num; i++){
+		if(!strcmp(file_name,gpio_data->rp_gpio_num[i].gpio_name)){
+			open_now = i;
+		}
+	}
+	return 0;
+}
+
+
+static ssize_t gpio_write(struct file *file, const char *buffer,size_t count, loff_t *data)
+{
+	char buf[2]={0};
+	char s1[]="1";
+	
+	if(copy_from_user(&buf[0],buffer,1)){
+		printk("failed to copy data to kernel space\n");
+		return -EFAULT;     
+	}
+
+	if(!strcmp(buf,s1)){
+	//	gpio_direction_output(gpio_data->rp_gpio_num[open_now].gpio_num,1);
+		gpio_set_value_cansleep(gpio_data->rp_gpio_num[open_now].gpio_num,1);
+	//	printk("%s write 1 succeed\n",gpio_data->rp_gpio_num[open_now].gpio_name);
+	}else{	
+	//	gpio_direction_output(gpio_data->rp_gpio_num[open_now].gpio_num,0);
+		gpio_set_value_cansleep(gpio_data->rp_gpio_num[open_now].gpio_num,0);
+	//	printk("%s write 0 succeed\n",gpio_data->rp_gpio_num[open_now].gpio_name);
+	}
+	return count;
+}
+
+
+static ssize_t gpio_read(struct file *file, char __user * buffer, size_t count, loff_t *data)
+{
+	int gpio_val = 0;
+	int len = 0;
+	char s[10] = {0};
+
+	if(*data)
+		return 0;
+
+	gpio_val = gpio_get_value_cansleep(gpio_data->rp_gpio_num[open_now].gpio_num);
+//	printk("get %s value %d\n",gpio_data->rp_gpio_num[open_now].gpio_name,gpio_val);
+
+	len = sprintf(s+len, "%d\n",gpio_val);	
+
+	return simple_read_from_buffer(buffer, count, data, s, 2);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+static const struct proc_ops gpio_ops = {
+    .proc_open           = gpio_open,
+    .proc_write          = gpio_write,
+    .proc_read           = gpio_read,
+};
+#else
+static const struct file_operations gpio_ops = {
+	.owner          = THIS_MODULE,
+    .open           = gpio_open,
+    .write          = gpio_write,
+    .read           = gpio_read,
+};
+#endif
+
+static struct workqueue_struct *my_workqueue;
+static struct work_struct my_work;
+
+static void send_event(struct work_struct *work)
+{
+	int gpio_value = 0;
+	int i = 0;
+	for(i = 0; i <= gpio_data->gpio_dts_num; i++) {
+		switch(gpio_data->rp_gpio_num[i].gpio_function) {
+			case GPIO_FUNCTION_INPUT :
+				gpio_value  = gpio_get_value_cansleep(gpio_data->rp_gpio_num[i].gpio_num);
+					
+					if(gpio_value == 1){
+						input_report_key(gpio_data->input, gpio_data->rp_gpio_num[i].gpio_event, 1);
+						input_sync(gpio_data->input);
+					}
+					if(gpio_value == 0){
+						input_report_key(gpio_data->input, gpio_data->rp_gpio_num[i].gpio_event, 0);
+						input_sync(gpio_data->input);
+					}
+				
+            //printk("\n%s gpio num %d  %d\n",__func__,gpio_data->rp_gpio_num[i].gpio_num,gpio_value);
+            //printk("\n%s send event %d\n",__func__,gpio_data->rp_gpio_num[i].gpio_event);
+				break;
+			case GPIO_FUNCTION_FLASH :
+			//	gpio_direction_output(gpio_data->rp_gpio_num[i].gpio_num,!flash_flag);
+				if(gpio_is_valid(gpio_data->rp_gpio_num[i].gpio_num)){
+					gpio_set_value_cansleep(gpio_data->rp_gpio_num[i].gpio_num,!flash_flag);
+					flash_flag = !flash_flag;
+				}
+				break;
+		}
+	}
+		
+	mod_timer(&(gpio_data->mytimer), jiffies + msecs_to_jiffies(1000));
+}	
+
+static void timer_callback(struct timer_list *t)
+{
+    schedule_work(&my_work);
+}
+
+static int rp_gpio_probe(struct platform_device *pdev) {
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child_np;
+	struct device *dev = &pdev->dev;
+	static struct proc_dir_entry *root_entry_gpio;
+	enum of_gpio_flags  gpio_flags;
+	int ret = 0;
+	int gpio_cnt = 0;	
+	char gpio_name_num[GPIO_NUM_MAX];
+	int gpio_in_cnt = 0;
+	int cnt =0;
+
+	gpio_data = devm_kzalloc(&pdev->dev, sizeof(struct rp_gpio_data),GFP_KERNEL);
+	if (!gpio_data) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	gpio_data->gpio_dts_num = of_get_child_count(np);
+        printk("rp_gpio prepare build %d gpio\n",gpio_data->gpio_dts_num);
+
+    	if (gpio_data->gpio_dts_num == 0){
+        	dev_info(&pdev->dev, "no gpio defined\n");
+	}
+
+	/* create node */
+	root_entry_gpio = proc_mkdir("rp_gpio", NULL);
+	
+	for_each_child_of_node(np, child_np)
+	{
+		/* parse dts */
+		gpio_data->rp_gpio_num[gpio_cnt].gpio_num = of_get_named_gpio_flags(child_np, "gpio_num", 0, &gpio_flags);
+		if (!gpio_is_valid(gpio_data->rp_gpio_num[gpio_cnt].gpio_num)){
+			printk("gpio %d is invalid!!!!\n", gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+		}		
+
+		gpio_data->rp_gpio_num[gpio_cnt].gpio_name = (char*)child_np -> name;
+		gpio_data->rp_gpio_num[gpio_cnt].action = gpio_flags;
+		gpio_data->rp_gpio_num[gpio_cnt].gpio_ctrl = gpio_cnt;
+		of_property_read_u32(child_np, "gpio_function", &(gpio_data->rp_gpio_num[gpio_cnt].gpio_function));
+
+		printk("rp_gpio request %s\n",gpio_data->rp_gpio_num[gpio_cnt].gpio_name);
+
+		
+		switch(gpio_data->rp_gpio_num[gpio_cnt].gpio_function) {
+			case GPIO_FUNCTION_INPUT :		/* init input gpio */
+				ret = gpio_request(gpio_data->rp_gpio_num[gpio_cnt].gpio_num, "gpio_num");
+				if (ret < 0)
+				{
+					printk("gpio%d request error\n",gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+				}else{
+					printk("success request gpio %d in\n",gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+
+					//gpio_direction_output(gpio_data->rp_gpio_num[gpio_cnt].gpio_num,!gpio_data->rp_gpio_num[gpio_cnt].action);
+					gpio_direction_input(gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+					event_flag = gpio_flags;
+					of_property_read_u32(child_np, "send_mode", &(gpio_data->rp_gpio_num[gpio_cnt].send_mode));
+					of_property_read_u32(child_np, "gpio_event", &(gpio_data->rp_gpio_num[gpio_cnt].gpio_event));
+					gpio_in_cnt++;
+				}
+				break;
+
+			case GPIO_FUNCTION_OUTPUT :		/* init output gpio */
+				ret = gpio_request(gpio_data->rp_gpio_num[gpio_cnt].gpio_num, "gpio_num");
+				if (ret < 0){
+					printk("gpio%d request error\n",gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+					//return ret;
+				}else{
+					gpio_direction_output(gpio_data->rp_gpio_num[gpio_cnt].gpio_num,!gpio_data->rp_gpio_num[gpio_cnt].action);
+					printk("success request gpio%d out\n",gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+				}
+				break;
+				
+			case GPIO_FUNCTION_FLASH :
+				ret = gpio_request(gpio_data->rp_gpio_num[gpio_cnt].gpio_num, "gpio_num");
+				if (ret < 0){
+					printk("gpio%d request error\n",gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+					//return ret;
+				}else{
+					gpio_direction_output(gpio_data->rp_gpio_num[gpio_cnt].gpio_num,!gpio_data->rp_gpio_num[gpio_cnt].action);
+					printk("success request gpio%d flash\n",gpio_data->rp_gpio_num[gpio_cnt].gpio_num);
+					gpio_in_cnt++;
+
+				}
+				break;
+		}
+		
+		sprintf(gpio_name_num,gpio_data->rp_gpio_num[gpio_cnt].gpio_name,gpio_cnt);
+		proc_create(gpio_name_num, 0666 , root_entry_gpio , &gpio_ops);
+		gpio_cnt++;
+	}
+	
+	if (gpio_in_cnt > 0)
+	{
+		// create workqueue
+		my_workqueue = create_workqueue("my_workqueue");
+
+		// init workqueue
+		INIT_WORK(&my_work, send_event);
+
+		// init timer
+		timer_setup(&gpio_data->mytimer, timer_callback, 0);
+
+		// set timer
+		mod_timer(&gpio_data->mytimer, jiffies + msecs_to_jiffies(10000));
+		
+		
+		/* init struct input_dev */ 
+		gpio_data->input = devm_input_allocate_device(dev);
+		gpio_data->input->name = "gpio_event";      /* pdev->name; */
+		gpio_data->input->phys = "gpio_event/input1";
+		gpio_data->input->dev.parent = dev;
+		gpio_data->input->id.bustype = BUS_HOST;
+		gpio_data->input->id.vendor = 0x0001;
+		gpio_data->input->id.product = 0x0001;
+		gpio_data->input->id.version = 0x0100;
+		for(cnt = 0; cnt < gpio_cnt; cnt++){
+			if (gpio_data->rp_gpio_num[cnt].gpio_function == 1){
+				input_set_capability(gpio_data->input, EV_KEY, gpio_data->rp_gpio_num[cnt].gpio_event);
+			}
+		}
+		ret = input_register_device(gpio_data->input);
+	}
+	
+	platform_set_drvdata(pdev, gpio_data);	
+	return 0;
+}
+
+static int rp_gpio_remove(struct platform_device *pdev)
+{
+    return 0;
+}
+
+
+static const struct of_device_id rp_gpio_of_match[] = {
+    { .compatible = "rp_gpio" },
+    { }
+};
+
+static struct platform_driver rp_gpio_driver = {
+    .probe = rp_gpio_probe,
+    .remove = rp_gpio_remove,
+    .driver = {
+                .name           = "rp_gpio",
+                .of_match_table = of_match_ptr(rp_gpio_of_match),
+        },
+};
+
+module_platform_driver(rp_gpio_driver);
+MODULE_LICENSE("GPL");
diff --git a/drivers/rongpin/rp_keys.c b/drivers/rongpin/rp_keys.c
new file mode 100644
index 000000000000..6b112d622d24
--- /dev/null
+++ b/drivers/rongpin/rp_keys.c
@@ -0,0 +1,440 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/spinlock.h>
+#include <dt-bindings/input/gpio-keys.h>
+#include <linux/device.h>
+
+#define rptips(str, ...) printk("rptips: "str, ##__VA_ARGS__)
+
+struct gpio_keys_button {
+    unsigned int code;
+    int active_low;
+    const char *label;
+    unsigned int type;
+    int wakeup;
+    int debounce_interval;
+    int value;
+    /*unsigned int trigger;*/
+    unsigned int press_type;// >0:long | 0:short
+};
+
+struct gpio_keys_platform_data {
+    const struct gpio_keys_button *buttons;
+    int nbuttons;
+    unsigned int rep:1;
+    const char *label;
+};
+
+struct gpio_button_data {
+        const struct gpio_keys_button *button;
+        struct input_dev *input;
+        struct gpio_desc *gpiod;
+        unsigned short *code;
+        struct delayed_work work;
+        unsigned int press;	
+        unsigned int irq;
+};
+
+struct gpio_keys_drvdata {
+        const struct gpio_keys_platform_data *pdata;
+        struct input_dev *input;
+        unsigned short *keymap;	
+        struct gpio_button_data data[];
+};
+
+static int gpio_keys_enable_wakeup(struct gpio_keys_drvdata *ddata);
+static int gpio_keys_button_enable_wakeup(struct gpio_button_data *bdata);
+static void gpio_keys_gpio_work_func(struct work_struct *work);
+static irqreturn_t gpio_keys_gpio_isr(int irq, void *dev_id);
+static struct gpio_keys_platform_data* gpio_keys_get_data_from_devtree(struct device *dev);
+static int gpio_keys_setup_key(struct platform_device *pdev, struct input_dev *input,
+                struct gpio_keys_drvdata *ddata, const struct gpio_keys_button *button,
+                int idx, struct fwnode_handle *child);
+static int gpio_keys_probe(struct platform_device *pdev);
+
+static void gpio_keys_gpio_work_func(struct work_struct *work){
+	struct gpio_button_data *bdata =
+        container_of(work, struct gpio_button_data, work.work);
+	struct input_dev *input = bdata->input;
+	int val;
+	
+	val = gpiod_get_value_cansleep(bdata->gpiod);
+    	if (val < 0) {
+        	rptips("err get gpio val: %d\n", val);
+        	return;
+    	}
+        input_event(input, EV_KEY, *bdata->code, !!val);
+        input_sync(input);
+	bdata->press = !!val;
+	if (bdata->button->wakeup)
+        	pm_relax(bdata->input->dev.parent);
+
+}
+
+static irqreturn_t gpio_keys_gpio_isr(int irq, void *dev_id){
+// interrupt service routine
+	struct gpio_button_data *bdata = dev_id;
+
+	if(bdata->button->wakeup) 
+		pm_stay_awake(bdata->input->dev.parent);
+	
+	mod_delayed_work(system_wq,
+             &bdata->work,
+             msecs_to_jiffies(bdata->button->debounce_interval + !bdata->press * bdata->button->press_type * 1000));
+
+	return IRQ_HANDLED;
+}
+
+static struct gpio_keys_platform_data*
+gpio_keys_get_data_from_devtree(struct device *dev){
+// parse data from device tree to platform data
+	int nbuttons = 0;
+	struct gpio_keys_platform_data *pdata;
+	struct gpio_keys_button *button;
+	struct fwnode_handle *child;
+
+	nbuttons = device_get_child_node_count(dev);
+	if(!nbuttons){
+		rptips("no keys dev\n");
+		return ERR_PTR(-ENODEV);
+	}
+	rptips("button number: %d\n", nbuttons);
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata) + nbuttons * sizeof(*button), GFP_KERNEL);
+	if(!pdata){
+		rptips("data alloc failed\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	button = (struct gpio_keys_button*)(pdata + 1);
+
+	pdata->buttons = button;
+	pdata->nbuttons = nbuttons;
+
+	device_property_read_string(dev, "label", &pdata->label);
+	pdata->rep = device_property_read_bool(dev, "autorepeat");
+
+	device_for_each_child_node(dev, child){
+		fwnode_property_read_string(child, "label", &button->label);
+
+		button->type = EV_KEY;
+		if(fwnode_property_read_u32(child, "code", &button->code)){
+			rptips("use default code : 1");
+			button->code = 1;
+		}
+		rptips("code = %u\n", button->code);
+
+		button->wakeup = fwnode_property_read_bool(child, "wakeup");
+		rptips("wakeup=%d\n", button->wakeup);
+
+		if(fwnode_property_read_u32(child, "debounce_interval", &button->debounce_interval)){
+			button->debounce_interval = 10;
+		}
+		rptips("debounce interval=%d\n", button->debounce_interval);
+
+		
+		if(fwnode_property_read_u32(child, "press_type", &button->press_type)){
+			button->press_type = 0;
+		}
+
+		button ++;
+	}
+
+	return pdata;
+}
+
+
+static int gpio_keys_setup_key(struct platform_device *pdev,
+                struct input_dev *input,
+                struct gpio_keys_drvdata *ddata,
+                const struct gpio_keys_button *button,
+                int idx,
+                struct fwnode_handle *child){
+// setup key
+	const char *label = button->label ? button->label : "rp_keys";
+	struct device *dev = &pdev->dev;
+	struct gpio_button_data *bdata = &ddata->data[idx];
+	irq_handler_t isr;
+	unsigned long irqflags;
+	int gpio = -1, bank = -1, group = -1;
+	int irq;
+	int error;
+	bool active_low;
+	char gpioname[10];
+
+	bdata->input = input;
+	bdata->button = button;
+	
+	bdata->gpiod = 
+		devm_fwnode_get_gpiod_from_child(dev, NULL, child, GPIOD_IN, label);
+	if(IS_ERR(bdata->gpiod)){
+		rptips("failed to get gpio, errnum:%ld\n", PTR_ERR(bdata->gpiod));
+		return PTR_ERR(bdata->gpiod);
+	}
+	gpio = desc_to_gpio(bdata->gpiod);
+	
+	group = gpio / 32;
+	bank = (gpio - (group * 32)) / 8;
+	sprintf(gpioname, "GPIO%d%c%d", bank, 'A' + bank, gpio - group * 32 - bank * 8);
+
+	rptips("gpio %d : %s\n", gpio, gpioname);
+
+	active_low = gpiod_is_active_low(bdata->gpiod);
+	rptips("active low : %d\n", active_low);
+	
+	irq = gpiod_to_irq(bdata->gpiod);
+	if(irq < 0){
+		rptips("err get irq for gpio %s\n", gpioname);
+		return irq;
+	}
+	bdata->irq = irq;
+	rptips("irq %d\n attach %s\n", irq, gpioname);
+
+	INIT_DELAYED_WORK(&bdata->work, gpio_keys_gpio_work_func);
+	
+	bdata->press = 0;
+
+
+	bdata->code = &ddata->keymap[idx];
+	*bdata->code = button->code;
+	input_set_capability(input, EV_KEY, *bdata->code);
+
+	isr = gpio_keys_gpio_isr;
+	irqflags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;
+	error = devm_request_any_context_irq(dev, bdata->irq, isr, irqflags, label, bdata);
+	if(error < 0) {
+		rptips("request irq %d failed\n", bdata->irq);
+		return error;
+	}
+	
+	return 0;
+}
+
+static int gpio_keys_probe(struct platform_device *pdev){
+// probe
+	struct device *dev = &pdev->dev;
+	const struct gpio_keys_platform_data *pdata; 
+	struct fwnode_handle *child = NULL;
+	struct gpio_keys_drvdata *ddata;
+	struct input_dev *input;
+	size_t size;
+	int i, error, wakeup = 0;
+	
+	pdata = gpio_keys_get_data_from_devtree(dev);
+	if(IS_ERR(pdata))
+		return PTR_ERR(pdata);
+
+	size = sizeof(struct gpio_keys_drvdata) + 
+			pdata->nbuttons * sizeof(struct gpio_button_data);
+	ddata = devm_kzalloc(dev, size, GFP_KERNEL);
+	if(!ddata) {
+		rptips("failed to allocate ddata\n");
+		return -ENOMEM;
+	}
+
+	ddata->keymap = 
+		devm_kcalloc(dev, pdata->nbuttons, sizeof(ddata->keymap[0]), GFP_KERNEL);
+	if(!ddata->keymap)
+		return -ENOMEM;
+
+	input = devm_input_allocate_device(dev);
+	if(!input) {
+		rptips("failed to allocate input dev\n");
+		return -ENOMEM;
+	}
+
+	ddata->pdata = pdata;
+	ddata->input = input;
+	
+	input->name = pdev->name;
+	input->dev.parent = dev;
+
+
+	input->keycode = ddata->keymap;
+	input->keycodesize = sizeof(ddata->keymap[0]);
+	input->keycodemax = pdata->nbuttons;
+
+	if(pdata->rep)
+		__set_bit(EV_REP, input->evbit);
+
+	for(i = 0; i < pdata->nbuttons; i ++) {
+		const struct gpio_keys_button *button = &pdata->buttons[i];
+
+		child = device_get_next_child_node(dev, child);
+		if(!child) {
+			rptips("no child device node\n");
+			return -EINVAL;
+		}
+
+		error = gpio_keys_setup_key(pdev, input, ddata, button, i, child);
+		if(error) {
+			fwnode_handle_put(child);
+			return error;
+		}
+
+		if(button->wakeup)
+			wakeup = 1;
+	}
+	fwnode_handle_put(child);
+
+	error = input_register_device(input);
+	if(error) {
+		rptips("unable to register input dev\n");
+		return error;
+	}
+
+	platform_set_drvdata(pdev, ddata);
+        input_set_drvdata(input, ddata);
+
+	if(wakeup){
+		error = device_init_wakeup(dev, wakeup);
+		rptips("init wakeup,ret = %d\n", error);
+		// gpio_keys_enable_wakeup(ddata);
+	}
+
+	return 0;
+}
+
+
+static int
+gpio_keys_button_enable_wakeup(struct gpio_button_data *bdata)
+{
+    int error;
+
+    error = enable_irq_wake(bdata->irq);
+    if (error) {
+        rptips("failed setup wakeup source IRQ: %d by err: %d\n",
+            bdata->irq, error);
+        return error;
+    }
+
+    error = irq_set_irq_type(bdata->irq, IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING);
+    if (error) {
+        rptips("failed to set wakeup trigger for IRQ %d: %d\n", bdata->irq, error);
+        disable_irq_wake(bdata->irq);
+        return error;
+    }
+
+    return 0;
+}
+
+static int 
+gpio_keys_enable_wakeup(struct gpio_keys_drvdata *ddata)
+{
+    struct gpio_button_data *bdata;
+    int error;
+    int i;
+
+    for (i = 0; i < ddata->pdata->nbuttons; i++) {
+        bdata = &ddata->data[i];
+        if (bdata->button->wakeup) {
+            error = gpio_keys_button_enable_wakeup(bdata);
+            if (error)
+		return error;
+        }
+    }
+
+    return 0;
+
+}
+
+static void __maybe_unused
+gpio_keys_button_disable_wakeup(struct gpio_button_data *bdata)
+{
+        int error;
+
+        error = disable_irq_wake(bdata->irq);
+        if (error)
+                rptips("failed to disable wakeup src IRQ %d: %d\n", bdata->irq, error);
+}
+
+static void __maybe_unused
+gpio_keys_disable_wakeup(struct gpio_keys_drvdata *ddata)
+{
+        struct gpio_button_data *bdata;
+        int i;
+
+        for (i = 0; i < ddata->pdata->nbuttons; i++) {
+                bdata = &ddata->data[i];
+                if (irqd_is_wakeup_set(irq_get_irq_data(bdata->irq)))
+                        gpio_keys_button_disable_wakeup(bdata);
+        }
+}
+
+static int __maybe_unused gpio_keys_suspend(struct device *dev)
+{
+        struct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);
+        int error;
+	
+        if (device_may_wakeup(dev)) {
+                error = gpio_keys_enable_wakeup(ddata);
+                if (error)
+                        return error;
+        }
+        return 0;
+}
+
+static int __maybe_unused gpio_keys_resume(struct device *dev)
+{
+	struct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);
+
+        if (device_may_wakeup(dev)) {
+                gpio_keys_disable_wakeup(ddata);
+	}
+
+        return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(gpio_keys_pm_ops, gpio_keys_suspend, gpio_keys_resume);
+
+// device match table
+static const struct of_device_id gpio_keys_of_match[] = {
+    { .compatible = "rp-keys", },
+    { },
+};
+
+MODULE_DEVICE_TABLE(of, gpio_keys_of_match);
+
+// driver descrition
+static struct platform_driver gpio_keys_device_driver = {
+    .probe      = gpio_keys_probe,
+    .driver     = {
+        .name   = "rp-keys",
+        .of_match_table = gpio_keys_of_match,
+	.pm = &gpio_keys_pm_ops,
+
+    }
+};
+
+static int __init gpio_keys_init(void)
+{
+    return platform_driver_register(&gpio_keys_device_driver);
+}
+
+static void __exit gpio_keys_exit(void)
+{
+    platform_driver_unregister(&gpio_keys_device_driver);
+}
+
+late_initcall_sync(gpio_keys_init);
+module_exit(gpio_keys_exit);
+
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/rongpin/rp_power.c b/drivers/rongpin/rp_power.c
new file mode 100644
index 000000000000..dab25b2836ad
--- /dev/null
+++ b/drivers/rongpin/rp_power.c
@@ -0,0 +1,349 @@
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+// #include <linux/wakelock.h>
+#include <linux/version.h>
+#include <linux/workqueue.h>
+
+#define GPIO_NUM_MAX 40
+
+#define GPIO_FUNCTION_OUTPUT 0
+#define GPIO_FUNCTION_INPUT 1
+#define GPIO_FUNCTION_IRQ 2
+#define GPIO_FUNCTION_FLASH 3
+#define GPIO_FUNCTION_OUTPUT_CTRL 4
+
+#define ANDROID_START "3"
+
+static int flash_flag = 0;
+
+struct rp_power {
+	int gpio_num;		//gpui num
+	int gpio_irq;
+	int action;			//gpio flag
+	int gpio_event;		//input only
+	int send_mode;		//input only
+	int gpio_function;	//gpio function,i/o
+	int gpio_ctrl;
+	char *gpio_name;
+};
+
+struct rp_power_data {
+	struct rp_power rp_power_num[GPIO_NUM_MAX];
+	struct input_dev *input;
+	struct timer_list mytimer;
+	int gpio_dts_num;
+};
+
+static struct rp_power_data *gpio_data = NULL;
+static int event_flag = 0;
+static int open_now = 0;
+static char* file_name = NULL;
+
+static int sleep_flag = 0;
+// static struct wake_lock rp_wake_lock;
+
+
+static int gpio_open(struct inode *inode, struct file *file)
+{
+	struct dentry* dent = file->f_path.dentry;
+	int i = 0;
+
+	file_name = (char*)(dent->d_name.name);
+
+	for (i = 0; i < gpio_data->gpio_dts_num; i++){
+		if(!strcmp(file_name,gpio_data->rp_power_num[i].gpio_name)){
+			open_now = i;
+		}
+	}
+	return 0;
+}
+
+
+static ssize_t gpio_write(struct file *file, const char *buffer,size_t count, loff_t *data)
+{
+	char buf[2]={0};
+	char s1[]="1";
+	
+	if(copy_from_user(&buf[0],buffer,1)){
+		printk("failed to copy data to kernel space\n");
+		return -EFAULT;     
+	}
+
+	if(!strcmp(buf,ANDROID_START) && !strcmp(gpio_data->rp_power_num[open_now].gpio_name,"led")){
+		gpio_data->rp_power_num[open_now].gpio_function = 3;
+		//printk("Android start now!\n");
+		return count;
+	}
+
+	if(!strcmp(buf,s1)){
+		//gpio_direction_output(gpio_data->rp_power_num[open_now].gpio_num,1);
+		gpio_set_value_cansleep(gpio_data->rp_power_num[open_now].gpio_num,1);
+		//printk("%s write 1 succeed\n",gpio_data->rp_power_num[open_now].gpio_name);
+	}else{	
+		//gpio_direction_output(gpio_data->rp_power_num[open_now].gpio_num,0);
+		gpio_set_value_cansleep(gpio_data->rp_power_num[open_now].gpio_num,0);
+		//printk("%s write 0 succeed\n",gpio_data->rp_power_num[open_now].gpio_name);
+	}
+	return count;
+}
+
+
+static ssize_t gpio_read(struct file *file, char __user * buffer, size_t count, loff_t *data)
+{
+	int gpio_val = 0;
+	int len = 0;
+	char s[10] = {0};
+
+	if(*data)
+		return 0;
+
+	gpio_val = gpio_get_value_cansleep(gpio_data->rp_power_num[open_now].gpio_num);
+	//printk("get %s value %d\n",gpio_data->rp_power_num[open_now].gpio_name,gpio_val);
+
+	len = sprintf(s+len, "%d\n",gpio_val);	
+
+	return simple_read_from_buffer(buffer, count, data, s, 2);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+static const struct proc_ops gpio_ops = {
+	.proc_open           = gpio_open,
+	.proc_write          = gpio_write,	
+	.proc_read           = gpio_read,
+};
+#else
+static const struct file_operations gpio_ops = {
+	.owner          = THIS_MODULE,
+    .open           = gpio_open,
+    .write          = gpio_write,
+    .read           = gpio_read,
+};
+#endif
+
+static struct workqueue_struct *my_workqueue;
+static struct work_struct my_work;
+
+static void send_event(struct work_struct *work)
+{    
+    int gpio_value = 0;
+	int i = 0;
+    
+    //printk("Work function executed\n");
+    
+	for(i = 0; i <= gpio_data->gpio_dts_num; i++) {
+		switch(gpio_data->rp_power_num[i].gpio_function) {
+			case GPIO_FUNCTION_INPUT :
+				gpio_value  = gpio_get_value_cansleep(gpio_data->rp_power_num[i].gpio_num);
+					
+                if(gpio_value == 1){
+                    input_report_key(gpio_data->input, gpio_data->rp_power_num[i].gpio_event, 1);
+                    input_sync(gpio_data->input);
+                }
+                if(gpio_value == 0){
+                    input_report_key(gpio_data->input, gpio_data->rp_power_num[i].gpio_event, 0);
+                    input_sync(gpio_data->input);
+                }
+				
+            //printk("\n%s gpio num %d  %d\n",__func__,gpio_data->rp_power_num[i].gpio_num,gpio_value);
+            //printk("\n%s send event %d\n",__func__,gpio_data->rp_power_num[i].gpio_event);
+				break;
+			case GPIO_FUNCTION_FLASH :
+				//gpio_direction_output(gpio_data->rp_power_num[i].gpio_num,!flash_flag);
+				if(gpio_is_valid(gpio_data->rp_power_num[i].gpio_num)){
+					gpio_set_value_cansleep(gpio_data->rp_power_num[i].gpio_num,!flash_flag);
+					flash_flag = !flash_flag;
+				}
+				break;
+		}
+	}
+		
+	mod_timer(&(gpio_data->mytimer), jiffies + msecs_to_jiffies(1000));
+}
+
+static void timer_callback(struct timer_list *t)
+{
+    // ��������������������
+    schedule_work(&my_work);
+}
+
+static int rp_power_probe(struct platform_device *pdev) {
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child_np;
+	struct device *dev = &pdev->dev;
+	static struct proc_dir_entry *root_entry_gpio;
+	enum of_gpio_flags  gpio_flags;
+	int ret = 0;
+	int gpio_cnt = 0;	
+	char gpio_name_num[GPIO_NUM_MAX];
+	int cnt =0;
+
+	gpio_data = devm_kzalloc(&pdev->dev, sizeof(struct rp_power_data),GFP_KERNEL);
+	if (!gpio_data) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	gpio_data->gpio_dts_num = of_get_child_count(np);
+        printk("rp_power prepare build %d gpio\n",gpio_data->gpio_dts_num);
+
+    	if (gpio_data->gpio_dts_num == 0){
+        	dev_info(&pdev->dev, "no gpio defined\n");
+	}
+
+	/* create node */
+	root_entry_gpio = proc_mkdir("rp_power", NULL);
+	
+	for_each_child_of_node(np, child_np)
+	{
+		/* parse dts */
+		gpio_data->rp_power_num[gpio_cnt].gpio_num = of_get_named_gpio_flags(child_np, "gpio_num", 0, &gpio_flags);
+		if (!gpio_is_valid(gpio_data->rp_power_num[gpio_cnt].gpio_num)){
+			printk("gpio %d is invalid!!!!\n", gpio_data->rp_power_num[gpio_cnt].gpio_num);
+		}		
+
+		gpio_data->rp_power_num[gpio_cnt].gpio_name = (char*)child_np -> name;
+		gpio_data->rp_power_num[gpio_cnt].action = gpio_flags;
+		gpio_data->rp_power_num[gpio_cnt].gpio_ctrl = gpio_cnt;
+		of_property_read_u32(child_np, "gpio_function", &(gpio_data->rp_power_num[gpio_cnt].gpio_function));
+
+		printk("rp_power request %s\n",gpio_data->rp_power_num[gpio_cnt].gpio_name);
+
+		
+		switch(gpio_data->rp_power_num[gpio_cnt].gpio_function) {
+			case GPIO_FUNCTION_INPUT :		/* init input gpio */
+				ret = gpio_request(gpio_data->rp_power_num[gpio_cnt].gpio_num, "gpio_num");
+				if (ret < 0)
+				{
+					printk("gpio%d request error\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+				}else{
+					printk("success request gpio %d in\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+
+					//gpio_direction_output(gpio_data->rp_power_num[gpio_cnt].gpio_num,!gpio_data->rp_power_num[gpio_cnt].action);
+					gpio_direction_input(gpio_data->rp_power_num[gpio_cnt].gpio_num);
+					event_flag = gpio_flags;
+					of_property_read_u32(child_np, "send_mode", &(gpio_data->rp_power_num[gpio_cnt].send_mode));
+					of_property_read_u32(child_np, "gpio_event", &(gpio_data->rp_power_num[gpio_cnt].gpio_event));
+				}
+				break;
+
+			case GPIO_FUNCTION_OUTPUT :		/* init output gpio */
+				ret = gpio_request(gpio_data->rp_power_num[gpio_cnt].gpio_num, "gpio_num");
+				if (ret < 0){
+					printk("gpio%d request error\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+					//return ret;
+				}else{
+					gpio_direction_output(gpio_data->rp_power_num[gpio_cnt].gpio_num,!gpio_data->rp_power_num[gpio_cnt].action);
+					printk("success request gpio%d out\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+				}
+				break;
+				
+			case GPIO_FUNCTION_FLASH :
+				ret = gpio_request(gpio_data->rp_power_num[gpio_cnt].gpio_num, "gpio_num");
+				if (ret < 0){
+					printk("gpio%d request error\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+					//return ret;
+				}else{
+					gpio_direction_output(gpio_data->rp_power_num[gpio_cnt].gpio_num,!gpio_data->rp_power_num[gpio_cnt].action);
+					printk("success request gpio%d flash\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+				}
+				break;
+				
+			case GPIO_FUNCTION_OUTPUT_CTRL :		/* init output gpio for proc */
+				ret = gpio_request(gpio_data->rp_power_num[gpio_cnt].gpio_num, "gpio_num");
+				if (ret < 0){
+					printk("gpio%d request error\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+					//return ret;
+				}else{
+					ret = gpio_direction_output(gpio_data->rp_power_num[gpio_cnt].gpio_num,!gpio_data->rp_power_num[gpio_cnt].action);
+					if (ret == 0)
+						printk("success request gpio%d out\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+					else
+						printk("faided to request gpio%d out\n",gpio_data->rp_power_num[gpio_cnt].gpio_num);
+				}
+				
+				sprintf(gpio_name_num,gpio_data->rp_power_num[gpio_cnt].gpio_name,gpio_cnt);
+				proc_create(gpio_name_num, 0666 , root_entry_gpio , &gpio_ops);
+				
+				break;
+		}
+		gpio_cnt++;
+	}
+    // create workqueue
+    my_workqueue = create_workqueue("my_workqueue");
+
+    // init workqueue
+    INIT_WORK(&my_work, send_event);
+
+    // init timer
+    timer_setup(&gpio_data->mytimer, timer_callback, 0);
+
+    // set timer
+    mod_timer(&gpio_data->mytimer, jiffies + msecs_to_jiffies(10000));
+    
+    /* init struct input_dev */ 
+    gpio_data->input = devm_input_allocate_device(dev);
+    gpio_data->input->name = "gpio_event";      /* pdev->name; */
+    gpio_data->input->phys = "gpio_event/input1";
+    gpio_data->input->dev.parent = dev;
+    gpio_data->input->id.bustype = BUS_HOST;
+    gpio_data->input->id.vendor = 0x0001;
+    gpio_data->input->id.product = 0x0001;
+    gpio_data->input->id.version = 0x0100;
+    for(cnt = 0; cnt < gpio_cnt; cnt++){
+        if (gpio_data->rp_power_num[cnt].gpio_function == 1){
+            input_set_capability(gpio_data->input, EV_KEY, gpio_data->rp_power_num[cnt].gpio_event);
+        }
+    }
+    
+    ret = input_register_device(gpio_data->input);
+	
+	of_property_read_u32(np, "rp_not_deep_leep", &sleep_flag);
+	if(sleep_flag != 0){
+		printk("rpdzkj wake lock\n");
+		// wake_lock_init(&rp_wake_lock,WAKE_LOCK_SUSPEND, "rpdzkj_no_deep_sleep");
+		// wake_lock(&rp_wake_lock);
+	}
+	
+	platform_set_drvdata(pdev, gpio_data);	
+	return 0;
+}
+
+static int rp_power_remove(struct platform_device *pdev)
+{
+    return 0;
+}
+
+
+static const struct of_device_id rp_power_of_match[] = {
+    { .compatible = "rp_power" },
+    { }
+};
+
+static struct platform_driver rp_power_driver = {
+    .probe = rp_power_probe,
+    .remove = rp_power_remove,
+    .driver = {
+                .name           = "rp_power",
+                .of_match_table = of_match_ptr(rp_power_of_match),
+        },
+};
+
+module_platform_driver(rp_power_driver);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/rongpin/stm706.c b/drivers/rongpin/stm706.c
new file mode 100644
index 000000000000..472f27767fd3
--- /dev/null
+++ b/drivers/rongpin/stm706.c
@@ -0,0 +1,171 @@
+/*
+ * GPIO driver for RICOH583 power management chip.
+ *
+ * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
+ * Author: Laxman dewangan <ldewangan@nvidia.com>
+ *
+ * Based on code
+ *	Copyright (C) 2011 RICOH COMPANY,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+
+struct stm_gpio{
+	int reset_gpio;
+	int wdt_gpio;
+};
+
+static struct timer_list mytimer;
+static struct stm_gpio stm706_gpio;
+static int wdi_status = 1;
+static int panic_test = 0;
+
+static ssize_t wtd_write(struct file *file, const char *buffer,size_t count, loff_t *data)
+{
+//	int * add;
+
+	panic_test = 1;
+	return count;
+/*
+	add = ioremap(0x0, 0x100);
+	*add = 0;
+			
+	return count;
+*/
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static const struct proc_ops wtd = {
+	.proc_write          = wtd_write,
+};
+#else
+static const struct file_operations wtd = {
+	.owner		= THIS_MODULE,
+	.write		= wtd_write,
+};
+#endif
+
+static struct proc_dir_entry *wtd_ctl_entry;
+
+void wdt_function(struct timer_list* list){
+//void wdt_function(unsigned long data){
+	wdi_status ^= 1;
+	
+	if (1 == panic_test){
+		return;
+	}
+
+	gpio_direction_output(stm706_gpio.wdt_gpio,wdi_status);
+	gpio_direction_output(stm706_gpio.reset_gpio,1);
+	mod_timer(&mytimer, jiffies + msecs_to_jiffies(200));
+	
+	return;
+}
+
+static int stm706_probe(struct platform_device *pdev)
+{
+	enum of_gpio_flags flags;
+	struct device_node *node = pdev->dev.of_node;
+	printk("start stm706 probe");
+
+	stm706_gpio.reset_gpio = of_get_named_gpio_flags(node, "reset_gpio", 0, &flags);
+	if (!gpio_is_valid(stm706_gpio.reset_gpio)){
+		printk("reset_gpio invalid gpio: %d\n",stm706_gpio.reset_gpio);
+	}
+	gpio_request(stm706_gpio.reset_gpio, "reset_gpio");
+	gpio_direction_output(stm706_gpio.reset_gpio,0);
+	printk("reset_gpio gpio: %d\n",stm706_gpio.reset_gpio);
+
+	stm706_gpio.wdt_gpio = of_get_named_gpio_flags(node, "wdt_gpio", 0, &flags);
+	if (!gpio_is_valid(stm706_gpio.wdt_gpio)){
+		printk("wdt_gpio invalid gpio: %d\n",stm706_gpio.wdt_gpio);
+	}
+	gpio_request(stm706_gpio.wdt_gpio, "wdt_gpio");
+	gpio_direction_output(stm706_gpio.wdt_gpio,wdi_status);
+	printk("wdt_gpio gpio: %d\n",stm706_gpio.wdt_gpio);	
+
+/*
+	init_timer(&mytimer);
+	mytimer.expires = jiffies + jiffies_to_msecs(2);
+	mytimer.function = wdt_function;
+	mytimer.data = 0;
+	add_timer(&mytimer);
+*/
+                timer_setup(&mytimer, wdt_function, 0);
+                mytimer.expires = jiffies + msecs_to_jiffies(200);
+                add_timer(&mytimer);
+
+	wtd_ctl_entry = proc_mkdir("wtd", NULL);
+	proc_create("wtd_ctrl",0666,wtd_ctl_entry,&wtd);
+
+	return 0;
+}
+
+static int stm706_remove(struct platform_device *pdev)
+{
+	del_timer(&mytimer);
+	return 0;
+}
+static int stm706_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	del_timer(&mytimer);
+	return 0;
+}
+static int stm706_resume(struct platform_device *pdev)
+{
+	add_timer(&mytimer);
+	return 0;
+}
+
+static struct of_device_id stm706_dt_ids[] = {
+	{ .compatible = "stm706" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm706_dt_ids);
+
+static struct platform_driver stm706_driver = {
+	.driver = {
+		.name    = "stm706",
+		.owner   = THIS_MODULE,
+		.of_match_table = of_match_ptr(stm706_dt_ids),
+	},
+	.suspend = stm706_suspend,
+	.resume = stm706_resume,
+	.probe		= stm706_probe,
+	.remove		= stm706_remove,
+};
+
+static int __init stm706_init(void)
+{
+	return platform_driver_register(&stm706_driver);
+}
+subsys_initcall(stm706_init);
+
+static void __exit stm706_exit(void)
+{
+	platform_driver_unregister(&stm706_driver);
+}
+module_exit(stm706_exit);
+
+MODULE_LICENSE("GPL");
+
-- 
Created with Armbian build tools https://github.com/armbian/build

